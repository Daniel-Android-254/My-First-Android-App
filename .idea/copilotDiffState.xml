<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/breathwatch/data/repository/AirQualityRepositoryImpl.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/breathwatch/data/repository/AirQualityRepositoryImpl.kt" />
              <option name="originalContent" value="package com.example.breathwatch.data.repository&#10;&#10;import com.example.breathwatch.data.local.dao.AirQualityDao&#10;import com.example.breathwatch.data.local.entity.AirQualityEntity&#10;import com.example.breathwatch.data.remote.api.AirQualityApi&#10;import com.example.breathwatch.data.remote.response.toAirQualityEntity&#10;import com.example.breathwatch.domain.repository.AirQualityRepository&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.flow&#10;import java.io.IOException&#10;import java.util.*&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class AirQualityRepositoryImpl @Inject constructor(&#10;    private val airQualityApi: AirQualityApi,&#10;    private val airQualityDao: AirQualityDao&#10;) : AirQualityRepository {&#10;&#10;    override suspend fun getAirQuality(latitude: Double, longitude: Double) = try {&#10;        // Try to get fresh data from API&#10;        val response = airQualityApi.getAirQuality(&quot;$latitude,$longitude&quot;)&#10;        val airQuality = response.toAirQualityEntity()&#10;        &#10;        // Save to local database&#10;        airQualityDao.insertAirQuality(airQuality)&#10;        &#10;        // Also save as cached data&#10;        val cachedAirQuality = airQuality.copy(isCached = true)&#10;        airQualityDao.insertAirQuality(cachedAirQuality)&#10;&#10;        Result.success(airQuality)&#10;    } catch (e: Exception) {&#10;        // If network fails, try to get from local database&#10;        val localAirQuality = airQualityDao.getAirQualityById(&#10;            AirQualityDao.getLocationId(latitude, longitude)&#10;        )&#10;        &#10;        if (localAirQuality != null) {&#10;            Result.success(localAirQuality)&#10;        } else {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    override fun observeAirQuality(latitude: Double, longitude: Double): Flow&lt;AirQualityEntity?&gt; {&#10;        return airQualityDao.observeAirQualityByLocation(latitude, longitude)&#10;    }&#10;&#10;    override suspend fun getAirQualityByLocationName(locationName: String) = try {&#10;        val response = airQualityApi.getAirQualityByCity(locationName)&#10;        val airQuality = response.toAirQualityEntity()&#10;        &#10;        // Save to local database&#10;        airQualityDao.insertAirQuality(airQuality)&#10;        &#10;        // Also save as cached data&#10;        val cachedAirQuality = airQuality.copy(isCached = true)&#10;        airQualityDao.insertAirQuality(cachedAirQuality)&#10;&#10;        Result.success(airQuality)&#10;    } catch (e: Exception) {&#10;        // If network fails, try to get from local database by name&#10;        val localAirQuality = airQualityDao.getLatestAirQualityByLocationName(locationName)&#10;        &#10;        if (localAirQuality != null) {&#10;            Result.success(localAirQuality)&#10;        } else {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    override suspend fun saveAirQuality(airQuality: AirQualityEntity) {&#10;        airQualityDao.insertAirQuality(airQuality)&#10;    }&#10;&#10;    override suspend fun getCachedAirQuality(): AirQualityEntity? {&#10;        return airQualityDao.getAirQualityById(&quot;cached&quot;)&#10;    }&#10;&#10;    override fun observeCachedAirQuality(): Flow&lt;AirQualityEntity?&gt; {&#10;        return airQualityDao.observeLatestCachedAirQuality()&#10;    }&#10;&#10;    override suspend fun getAirQualityHistory(&#10;        latitude: Double,&#10;        longitude: Double,&#10;        days: Int&#10;    ): Result&lt;List&lt;AirQualityEntity&gt;&gt; {&#10;        // In a real app, this would fetch historical data from the API&#10;        // For now, we'll return the latest data as a list with a single item&#10;        return try {&#10;            val current = getAirQuality(latitude, longitude).getOrThrow()&#10;            Result.success(listOf(current))&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    override suspend fun getAirQualityForDay(&#10;        latitude: Double,&#10;        longitude: Double,&#10;        timestamp: Long&#10;    ): Result&lt;List&lt;AirQualityEntity&gt;&gt; {&#10;        // In a real app, this would fetch data for a specific day&#10;        // For now, we'll just return the current data&#10;        return try {&#10;            val current = getAirQuality(latitude, longitude).getOrThrow()&#10;            Result.success(listOf(current))&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    private fun getCurrentDateTimestamp(): Long {&#10;        val calendar = Calendar.getInstance()&#10;        calendar.set(Calendar.HOUR_OF_DAY, 0)&#10;        calendar.set(Calendar.MINUTE, 0)&#10;        calendar.set(Calendar.SECOND, 0)&#10;        calendar.set(Calendar.MILLISECOND, 0)&#10;        return calendar.timeInMillis&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.breathwatch.data.repository&#10;&#10;import com.example.breathwatch.data.local.dao.AirQualityDao&#10;import com.example.breathwatch.data.local.entity.AirQualityEntity&#10;import com.example.breathwatch.data.remote.api.AirQualityApi&#10;import com.example.breathwatch.data.remote.response.toAirQualityEntity&#10;import com.example.breathwatch.domain.repository.AirQualityRepository&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.first&#10;import java.util.*&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class AirQualityRepositoryImpl @Inject constructor(&#10;    private val airQualityApi: AirQualityApi,&#10;    private val airQualityDao: AirQualityDao,&#10;    private val cacheStrategy: CacheStrategy&#10;) : AirQualityRepository, BaseRepository&lt;AirQualityEntity&gt; {&#10;&#10;    override suspend fun getAirQuality(latitude: Double, longitude: Double) = try {&#10;        require(latitude in -90.0..90.0) { &quot;Invalid latitude: $latitude&quot; }&#10;        require(longitude in -180.0..180.0) { &quot;Invalid longitude: $longitude&quot; }&#10;        &#10;        cacheStrategy.cachingStrategy(&#10;            dbQuery = { airQualityDao.observeAirQualityByLocation(latitude, longitude) },&#10;            networkCall = { &#10;                Result.wrap { &#10;                    airQualityApi.getAirQuality(&quot;$latitude,$longitude&quot;)&#10;                        .toAirQualityEntity()&#10;                        .copy(timestamp = System.currentTimeMillis()) &#10;                }&#10;            },&#10;            saveCallResult = { airQualityDao.insertAirQuality(it) },&#10;            shouldFetch = { cached -&gt; &#10;                cached == null || isDataStale(cached.timestamp, MAX_AGE) &#10;            }&#10;        ).first()&#10;    } catch (e: IllegalArgumentException) {&#10;        Result.Error(e)&#10;    } catch (e: Exception) {&#10;        Result.Error(e)&#10;    }&#10;&#10;    override fun observeAirQuality(latitude: Double, longitude: Double): Flow&lt;Result&lt;AirQualityEntity&gt;&gt; {&#10;        return cacheStrategy.cachingStrategy(&#10;            dbQuery = { airQualityDao.observeAirQualityByLocation(latitude, longitude) },&#10;            networkCall = { &#10;                Result.wrap { &#10;                    airQualityApi.getAirQuality(&quot;$latitude,$longitude&quot;)&#10;                        .toAirQualityEntity()&#10;                        .copy(timestamp = System.currentTimeMillis()) &#10;                }&#10;            },&#10;            saveCallResult = { airQualityDao.insertAirQuality(it) },&#10;            shouldFetch = { cached -&gt; &#10;                cached == null || isDataStale(cached.timestamp, MAX_AGE) &#10;            }&#10;        )&#10;    }&#10;&#10;    override suspend fun getAirQualityByLocationName(locationName: String) = try {&#10;        require(locationName.isNotBlank()) { &quot;Location name cannot be empty&quot; }&#10;        &#10;        cacheStrategy.cachingStrategy(&#10;            dbQuery = { airQualityDao.observeLatestAirQualityByLocationName(locationName) },&#10;            networkCall = { &#10;                Result.wrap { &#10;                    airQualityApi.getAirQualityByCity(locationName)&#10;                        .toAirQualityEntity()&#10;                        .copy(timestamp = System.currentTimeMillis()) &#10;                }&#10;            },&#10;            saveCallResult = { airQualityDao.insertAirQuality(it) },&#10;            shouldFetch = { cached -&gt; &#10;                cached == null || isDataStale(cached.timestamp, MAX_AGE) &#10;            }&#10;        ).first()&#10;    } catch (e: IllegalArgumentException) {&#10;        Result.Error(e)&#10;    } catch (e: Exception) {&#10;        Result.Error(e)&#10;    }&#10;&#10;    override suspend fun refresh() = try {&#10;        // Refresh all cached locations&#10;        val cachedLocations = airQualityDao.getAllLocations()&#10;        cachedLocations.forEach { location -&gt;&#10;            cacheStrategy.refreshData {&#10;                val response = airQualityApi.getAirQuality(location)&#10;                val entity = response.toAirQualityEntity()&#10;                    .copy(timestamp = System.currentTimeMillis())&#10;                airQualityDao.insertAirQuality(entity)&#10;            }&#10;        }&#10;        Result.Success(Unit)&#10;    } catch (e: Exception) {&#10;        Result.Error(e)&#10;    }&#10;&#10;    override fun observe(): Flow&lt;Result&lt;List&lt;AirQualityEntity&gt;&gt;&gt; {&#10;        return cacheStrategy.cachingStrategy(&#10;            dbQuery = { airQualityDao.observeAllAirQuality() },&#10;            networkCall = { refresh() },&#10;            saveCallResult = { /* Already saved in refresh() */ },&#10;            shouldFetch = { cached -&gt; &#10;                cached?.any { isDataStale(it.timestamp, MAX_AGE) } ?: true&#10;            }&#10;        )&#10;    }&#10;&#10;    override suspend fun get(): Result&lt;List&lt;AirQualityEntity&gt;&gt; = observe().first()&#10;&#10;    override suspend fun clear() {&#10;        airQualityDao.deleteAll()&#10;    }&#10;&#10;    companion object {&#10;        private const val MAX_AGE = 30 * 60 * 1000L // 30 minutes&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/breathwatch/data/repository/WeatherRepositoryImpl.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/breathwatch/data/repository/WeatherRepositoryImpl.kt" />
              <option name="originalContent" value="package com.example.breathwatch.data.repository&#10;&#10;import com.example.breathwatch.data.local.dao.WeatherDao&#10;import com.example.breathwatch.data.local.entity.WeatherEntity&#10;import com.example.breathwatch.data.remote.api.WeatherApi&#10;import com.example.breathwatch.data.remote.response.toWeatherEntity&#10;import com.example.breathwatch.domain.repository.WeatherRepository&#10;import kotlinx.coroutines.flow.Flow&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class WeatherRepositoryImpl @Inject constructor(&#10;    private val weatherApi: WeatherApi,&#10;    private val weatherDao: WeatherDao&#10;) : WeatherRepository {&#10;&#10;    override suspend fun getWeather(latitude: Double, longitude: Double) = try {&#10;        // Validate coordinates&#10;        require(latitude in -90.0..90.0) { &quot;Invalid latitude: $latitude&quot; }&#10;        require(longitude in -180.0..180.0) { &quot;Invalid longitude: $longitude&quot; }&#10;&#10;        // Try to get fresh data from API&#10;        val response = weatherApi.getWeather(&quot;$latitude,$longitude&quot;)&#10;        val weather = response.toWeatherEntity().copy(timestamp = System.currentTimeMillis())&#10;        &#10;        // Save to local database&#10;        weatherDao.insertWeather(weather)&#10;        &#10;        Result.success(weather)&#10;    } catch (e: IllegalArgumentException) {&#10;        Result.failure(e)&#10;    } catch (e: Exception) {&#10;        // If network fails, try to get from local database&#10;        try {&#10;            val localWeather = weatherDao.getWeatherById(&#10;                WeatherDao.getLocationId(latitude, longitude)&#10;            )&#10;            &#10;            if (localWeather != null &amp;&amp; !isWeatherDataStale(localWeather.timestamp)) {&#10;                Result.success(localWeather)&#10;            } else {&#10;                Result.failure(e)&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    override fun observeWeather(latitude: Double, longitude: Double): Flow&lt;WeatherEntity?&gt; {&#10;        return weatherDao.observeWeatherByLocation(latitude, longitude)&#10;    }&#10;&#10;    override suspend fun getWeatherByLocationName(locationName: String) = try {&#10;        require(locationName.isNotBlank()) { &quot;Location name cannot be empty&quot; }&#10;        &#10;        val response = weatherApi.getWeather(locationName)&#10;        val weather = response.toWeatherEntity().copy(timestamp = System.currentTimeMillis())&#10;        &#10;        // Save to local database&#10;        weatherDao.insertWeather(weather)&#10;        &#10;        Result.success(weather)&#10;    } catch (e: IllegalArgumentException) {&#10;        Result.failure(e)&#10;    } catch (e: Exception) {&#10;        // Try to get from local database by name&#10;        try {&#10;            val localWeather = weatherDao.getLatestWeatherByLocationName(locationName)&#10;            if (localWeather != null &amp;&amp; !isWeatherDataStale(localWeather.timestamp)) {&#10;                Result.success(localWeather)&#10;            } else {&#10;                Result.failure(e)&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    override suspend fun saveWeather(weather: WeatherEntity) {&#10;        weatherDao.insertWeather(weather)&#10;    }&#10;&#10;    private fun isWeatherDataStale(timestamp: Long): Boolean {&#10;        val currentTime = System.currentTimeMillis()&#10;        val dataAge = currentTime - timestamp&#10;        return dataAge &gt; WEATHER_DATA_STALENESS_THRESHOLD&#10;    }&#10;&#10;    companion object {&#10;        private const val WEATHER_DATA_STALENESS_THRESHOLD = 30 * 60 * 1000L // 30 minutes in milliseconds&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.breathwatch.data.repository&#10;&#10;import com.example.breathwatch.data.local.dao.WeatherDao&#10;import com.example.breathwatch.data.local.entity.WeatherEntity&#10;import com.example.breathwatch.data.remote.api.WeatherApi&#10;import com.example.breathwatch.data.remote.response.toWeatherEntity&#10;import com.example.breathwatch.domain.repository.WeatherRepository&#10;import kotlinx.coroutines.flow.Flow&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class WeatherRepositoryImpl @Inject constructor(&#10;    private val weatherApi: WeatherApi,&#10;    private val weatherDao: WeatherDao,&#10;    private val cacheStrategy: CacheStrategy&#10;) : WeatherRepository, BaseRepository&lt;WeatherEntity&gt; {&#10;&#10;    override suspend fun getWeather(latitude: Double, longitude: Double) = try {&#10;        require(latitude in -90.0..90.0) { &quot;Invalid latitude: $latitude&quot; }&#10;        require(longitude in -180.0..180.0) { &quot;Invalid longitude: $longitude&quot; }&#10;        &#10;        cacheStrategy.cachingStrategy(&#10;            dbQuery = { weatherDao.observeWeatherByLocation(latitude, longitude) },&#10;            networkCall = { &#10;                Result.wrap { &#10;                    weatherApi.getWeather(&quot;$latitude,$longitude&quot;)&#10;                        .toWeatherEntity()&#10;                        .copy(timestamp = System.currentTimeMillis()) &#10;                }&#10;            },&#10;            saveCallResult = { weatherDao.insertWeather(it) },&#10;            shouldFetch = { cached -&gt; &#10;                cached == null || isDataStale(cached.timestamp, MAX_AGE) &#10;            }&#10;        ).first()&#10;    } catch (e: IllegalArgumentException) {&#10;        Result.Error(e)&#10;    } catch (e: Exception) {&#10;        Result.Error(e)&#10;    }&#10;&#10;    override fun observeWeather(latitude: Double, longitude: Double): Flow&lt;Result&lt;WeatherEntity&gt;&gt; {&#10;        return cacheStrategy.cachingStrategy(&#10;            dbQuery = { weatherDao.observeWeatherByLocation(latitude, longitude) },&#10;            networkCall = { &#10;                Result.wrap { &#10;                    weatherApi.getWeather(&quot;$latitude,$longitude&quot;)&#10;                        .toWeatherEntity()&#10;                        .copy(timestamp = System.currentTimeMillis()) &#10;                }&#10;            },&#10;            saveCallResult = { weatherDao.insertWeather(it) },&#10;            shouldFetch = { cached -&gt; &#10;                cached == null || isDataStale(cached.timestamp, MAX_AGE) &#10;            }&#10;        )&#10;    }&#10;&#10;    override suspend fun getWeatherForecast(latitude: Double, longitude: Double) = try {&#10;        require(latitude in -90.0..90.0) { &quot;Invalid latitude: $latitude&quot; }&#10;        require(longitude in -180.0..180.0) { &quot;Invalid longitude: $longitude&quot; }&#10;        &#10;        cacheStrategy.cachingStrategy(&#10;            dbQuery = { weatherDao.observeForecastByLocation(latitude, longitude) },&#10;            networkCall = { &#10;                Result.wrap { &#10;                    weatherApi.getWeatherForecast(&quot;$latitude,$longitude&quot;)&#10;                        .toWeatherEntity()&#10;                        .copy(timestamp = System.currentTimeMillis()) &#10;                }&#10;            },&#10;            saveCallResult = { weatherDao.insertWeather(it) },&#10;            shouldFetch = { cached -&gt; &#10;                cached == null || isDataStale(cached.timestamp, FORECAST_MAX_AGE) &#10;            }&#10;        ).first()&#10;    } catch (e: IllegalArgumentException) {&#10;        Result.Error(e)&#10;    } catch (e: Exception) {&#10;        Result.Error(e)&#10;    }&#10;&#10;    override suspend fun getWeatherByLocationName(locationName: String) = try {&#10;        require(locationName.isNotBlank()) { &quot;Location name cannot be empty&quot; }&#10;        &#10;        cacheStrategy.cachingStrategy(&#10;            dbQuery = { weatherDao.observeLatestWeatherByLocationName(locationName) },&#10;            networkCall = { &#10;                Result.wrap { &#10;                    weatherApi.getWeather(locationName)&#10;                        .toWeatherEntity()&#10;                        .copy(timestamp = System.currentTimeMillis()) &#10;                }&#10;            },&#10;            saveCallResult = { weatherDao.insertWeather(it) },&#10;            shouldFetch = { cached -&gt; &#10;                cached == null || isDataStale(cached.timestamp, MAX_AGE) &#10;            }&#10;        ).first()&#10;    } catch (e: IllegalArgumentException) {&#10;        Result.Error(e)&#10;    } catch (e: Exception) {&#10;        Result.Error(e)&#10;    }&#10;&#10;    override suspend fun refresh() = try {&#10;        // Refresh all cached locations&#10;        val cachedLocations = weatherDao.getAllLocations()&#10;        cachedLocations.forEach { location -&gt;&#10;            cacheStrategy.refreshData {&#10;                val response = weatherApi.getWeather(location)&#10;                val entity = response.toWeatherEntity()&#10;                    .copy(timestamp = System.currentTimeMillis())&#10;                weatherDao.insertWeather(entity)&#10;            }&#10;        }&#10;        Result.Success(Unit)&#10;    } catch (e: Exception) {&#10;        Result.Error(e)&#10;    }&#10;&#10;    override fun observe(): Flow&lt;Result&lt;List&lt;WeatherEntity&gt;&gt;&gt; {&#10;        return cacheStrategy.cachingStrategy(&#10;            dbQuery = { weatherDao.observeAllWeather() },&#10;            networkCall = { refresh() },&#10;            saveCallResult = { /* Already saved in refresh() */ },&#10;            shouldFetch = { cached -&gt; &#10;                cached?.any { isDataStale(it.timestamp, MAX_AGE) } ?: true&#10;            }&#10;        )&#10;    }&#10;&#10;    override suspend fun get(): Result&lt;List&lt;WeatherEntity&gt;&gt; = observe().first()&#10;&#10;    override suspend fun clear() {&#10;        weatherDao.deleteAll()&#10;    }&#10;&#10;    companion object {&#10;        private const val MAX_AGE = 30 * 60 * 1000L // 30 minutes&#10;        private const val FORECAST_MAX_AGE = 3 * 60 * 60 * 1000L // 3 hours&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/breathwatch/util/WorkManagerScheduler.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/breathwatch/util/WorkManagerScheduler.kt" />
              <option name="originalContent" value="package com.example.breathwatch.util&#10;&#10;import android.content.Context&#10;import androidx.work.*&#10;import com.example.breathwatch.worker.AirQualitySyncWorker&#10;import java.util.concurrent.TimeUnit&#10;&#10;object WorkManagerScheduler {&#10;    &#10;    private const val MIN_FLEX_INTERVAL = 15L // 15 minutes minimum flex time&#10;    &#10;    fun schedulePeriodicSync(context: Context) {&#10;        val constraints = Constraints.Builder()&#10;            .setRequiredNetworkType(NetworkType.CONNECTED)&#10;            .setRequiresBatteryNotLow(true)&#10;            .setRequiresDeviceIdle(false)  // Allow running when device is active&#10;            .setRequiresCharging(false)     // Don't require charging&#10;            .build()&#10;&#10;        // Ensure minimum flex interval for better battery life&#10;        val flexInterval = (Constants.DEFAULT_REFRESH_INTERVAL_HOURS * 60 / 4)&#10;            .coerceAtLeast(MIN_FLEX_INTERVAL)&#10;&#10;        val syncWorkRequest = PeriodicWorkRequestBuilder&lt;AirQualitySyncWorker&gt;(&#10;            repeatInterval = Constants.DEFAULT_REFRESH_INTERVAL_HOURS,&#10;            repeatIntervalTimeUnit = TimeUnit.HOURS,&#10;            flexTimeInterval = flexInterval,&#10;            flexTimeIntervalUnit = TimeUnit.MINUTES&#10;        )&#10;            .setConstraints(constraints)&#10;            .addTag(Constants.SYNC_WORKER_TAG)&#10;            .setBackoffCriteria(&#10;                BackoffPolicy.EXPONENTIAL,&#10;                WorkRequest.MIN_BACKOFF_MILLIS,&#10;                TimeUnit.MILLISECONDS&#10;            )&#10;            .setInitialDelay(5, TimeUnit.MINUTES) // Initial delay to avoid immediate execution&#10;            .build()&#10;&#10;        WorkManager.getInstance(context).enqueueUniquePeriodicWork(&#10;            Constants.SYNC_WORKER_TAG,&#10;            ExistingPeriodicWorkPolicy.UPDATE, // Update existing work instead of keeping old&#10;            syncWorkRequest&#10;        )&#10;    }&#10;    &#10;    fun cancelPeriodicSync(context: Context) {&#10;        WorkManager.getInstance(context).cancelUniqueWork(Constants.SYNC_WORKER_TAG)&#10;    }&#10;    &#10;    fun scheduleOneTimeSync(context: Context) {&#10;        val constraints = Constraints.Builder()&#10;            .setRequiredNetworkType(NetworkType.CONNECTED)&#10;            .setRequiresBatteryNotLow(true)&#10;            .build()&#10;&#10;        val syncWorkRequest = OneTimeWorkRequestBuilder&lt;AirQualitySyncWorker&gt;()&#10;            .setConstraints(constraints)&#10;            .addTag(&quot;${Constants.SYNC_WORKER_TAG}_onetime&quot;)&#10;            .setBackoffCriteria(&#10;                BackoffPolicy.LINEAR,&#10;                WorkRequest.MIN_BACKOFF_MILLIS,&#10;                TimeUnit.MILLISECONDS&#10;            )&#10;            .build()&#10;&#10;        WorkManager.getInstance(context)&#10;            .enqueueUniqueWork(&#10;                &quot;${Constants.SYNC_WORKER_TAG}_onetime&quot;,&#10;                ExistingWorkPolicy.REPLACE,&#10;                syncWorkRequest&#10;            )&#10;    }&#10;&#10;    fun getWorkInfo(context: Context, callback: (List&lt;WorkInfo&gt;) -&gt; Unit) {&#10;        WorkManager.getInstance(context)&#10;            .getWorkInfosByTagLiveData(Constants.SYNC_WORKER_TAG)&#10;            .observeForever { workInfoList -&gt;&#10;                callback(workInfoList)&#10;            }&#10;    }&#10;&#10;    fun isPeriodWorkScheduled(context: Context, callback: (Boolean) -&gt; Unit) {&#10;        WorkManager.getInstance(context)&#10;            .getWorkInfosForUniqueWorkLiveData(Constants.SYNC_WORKER_TAG)&#10;            .observeForever { workInfoList -&gt;&#10;                val isScheduled = workInfoList?.any { &#10;                    it.state == WorkInfo.State.ENQUEUED || &#10;                    it.state == WorkInfo.State.RUNNING &#10;                } ?: false&#10;                callback(isScheduled)&#10;            }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.breathwatch.util&#10;&#10;import android.content.Context&#10;import android.os.Build&#10;import androidx.work.*&#10;import com.example.breathwatch.worker.AirQualitySyncWorker&#10;import com.example.breathwatch.worker.DataCleanupWorker&#10;import java.util.concurrent.TimeUnit&#10;&#10;object WorkManagerScheduler {&#10;    &#10;    private const val MIN_FLEX_INTERVAL = 15L // 15 minutes minimum flex time&#10;    private const val BACKOFF_DELAY = WorkRequest.MIN_BACKOFF_MILLIS&#10;    &#10;    fun schedulePeriodicSync(context: Context) {&#10;        val constraints = Constraints.Builder()&#10;            .setRequiredNetworkType(NetworkType.CONNECTED)&#10;            .setRequiresBatteryNotLow(true)&#10;            .setRequiresDeviceIdle(false)&#10;            .setRequiresCharging(false)&#10;            .setRequiresStorageNotLow(true)  // Ensure enough storage for caching&#10;            .build()&#10;&#10;        // Calculate optimal flex interval for battery efficiency&#10;        val flexInterval = (Constants.DEFAULT_REFRESH_INTERVAL_HOURS * 60 / 4)&#10;            .coerceAtLeast(MIN_FLEX_INTERVAL)&#10;&#10;        val syncWorkRequest = PeriodicWorkRequestBuilder&lt;AirQualitySyncWorker&gt;(&#10;            repeatInterval = Constants.DEFAULT_REFRESH_INTERVAL_HOURS,&#10;            repeatIntervalTimeUnit = TimeUnit.HOURS,&#10;            flexTimeInterval = flexInterval,&#10;            flexTimeIntervalUnit = TimeUnit.MINUTES&#10;        )&#10;            .setConstraints(constraints)&#10;            .addTag(Constants.SYNC_WORKER_TAG)&#10;            .setBackoffCriteria(&#10;                BackoffPolicy.EXPONENTIAL,&#10;                BACKOFF_DELAY,&#10;                TimeUnit.MILLISECONDS&#10;            )&#10;            .setInitialDelay(5, TimeUnit.MINUTES)&#10;            .build()&#10;&#10;        // Use unique work to ensure only one sync chain is active&#10;        WorkManager.getInstance(context).enqueueUniquePeriodicWork(&#10;            Constants.SYNC_WORKER_TAG,&#10;            ExistingPeriodicWorkPolicy.UPDATE,&#10;            syncWorkRequest&#10;        )&#10;&#10;        // Schedule cleanup work for old data&#10;        scheduleCleanupWork(context)&#10;    }&#10;    &#10;    private fun scheduleCleanupWork(context: Context) {&#10;        val cleanupWorkRequest = PeriodicWorkRequestBuilder&lt;DataCleanupWorker&gt;(&#10;            24, TimeUnit.HOURS&#10;        )&#10;            .setConstraints(&#10;                Constraints.Builder()&#10;                    .setRequiresDeviceIdle(true)&#10;                    .setRequiresBatteryNotLow(true)&#10;                    .build()&#10;            )&#10;            .addTag(&quot;${Constants.SYNC_WORKER_TAG}_cleanup&quot;)&#10;            .build()&#10;&#10;        WorkManager.getInstance(context).enqueueUniquePeriodicWork(&#10;            &quot;${Constants.SYNC_WORKER_TAG}_cleanup&quot;,&#10;            ExistingPeriodicWorkPolicy.KEEP,&#10;            cleanupWorkRequest&#10;        )&#10;    }&#10;    &#10;    fun cancelPeriodicSync(context: Context) {&#10;        WorkManager.getInstance(context).apply {&#10;            cancelUniqueWork(Constants.SYNC_WORKER_TAG)&#10;            cancelUniqueWork(&quot;${Constants.SYNC_WORKER_TAG}_cleanup&quot;)&#10;        }&#10;    }&#10;    &#10;    fun scheduleOneTimeSync(context: Context, expedited: Boolean = false) {&#10;        val constraints = Constraints.Builder()&#10;            .setRequiredNetworkType(NetworkType.CONNECTED)&#10;            .setRequiresBatteryNotLow(true)&#10;            .build()&#10;&#10;        val syncWorkRequest = OneTimeWorkRequestBuilder&lt;AirQualitySyncWorker&gt;()&#10;            .setConstraints(constraints)&#10;            .addTag(&quot;${Constants.SYNC_WORKER_TAG}_onetime&quot;)&#10;            .setBackoffCriteria(&#10;                BackoffPolicy.LINEAR,&#10;                BACKOFF_DELAY,&#10;                TimeUnit.MILLISECONDS&#10;            )&#10;            .apply {&#10;                if (expedited &amp;&amp; Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S) {&#10;                    setExpedited(OutOfQuotaPolicy.RUN_AS_NON_EXPEDITED_WORK_REQUEST)&#10;                }&#10;            }&#10;            .build()&#10;&#10;        WorkManager.getInstance(context)&#10;            .enqueueUniqueWork(&#10;                &quot;${Constants.SYNC_WORKER_TAG}_onetime&quot;,&#10;                ExistingWorkPolicy.REPLACE,&#10;                syncWorkRequest&#10;            )&#10;    }&#10;&#10;    fun getWorkInfo(context: Context, callback: (List&lt;WorkInfo&gt;) -&gt; Unit) {&#10;        WorkManager.getInstance(context)&#10;            .getWorkInfosByTagLiveData(Constants.SYNC_WORKER_TAG)&#10;            .observeForever { workInfoList -&gt;&#10;                callback(workInfoList)&#10;            }&#10;    }&#10;&#10;    fun isPeriodWorkScheduled(context: Context, callback: (Boolean) -&gt; Unit) {&#10;        WorkManager.getInstance(context)&#10;            .getWorkInfosForUniqueWorkLiveData(Constants.SYNC_WORKER_TAG)&#10;            .observeForever { workInfoList -&gt;&#10;                val isScheduled = workInfoList?.any { &#10;                    it.state == WorkInfo.State.ENQUEUED || &#10;                    it.state == WorkInfo.State.RUNNING &#10;                } ?: false&#10;                callback(isScheduled)&#10;            }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/build.gradle.kts" />
              <option name="originalContent" value="// Top-level build file where you can add configuration options common to all sub-projects/modules.&#10;buildscript {&#10;    val compose_version by extra(&quot;1.5.4&quot;)&#10;    val hilt_version by extra(&quot;2.48&quot;)&#10;    &#10;    repositories {&#10;        google()&#10;        mavenCentral()&#10;        gradlePluginPortal()&#10;    }&#10;    dependencies {&#10;        classpath(&quot;com.android.tools.build:gradle:8.1.0&quot;)&#10;        classpath(&quot;org.jetbrains.kotlin:kotlin-gradle-plugin:1.9.0&quot;)&#10;        classpath(&quot;com.google.dagger:hilt-android-gradle-plugin:${hilt_version}&quot;)&#10;    }&#10;}&#10;&#10;allprojects {&#10;    repositories {&#10;        google()&#10;        mavenCentral()&#10;    }&#10;}&#10;&#10;tasks.register(&quot;clean&quot;, Delete::class) {&#10;    delete(rootProject.buildDir)&#10;}&#10;" />
              <option name="updatedContent" value="// Top-level build file where you can add configuration options common to all sub-projects/modules.&#10;buildscript {&#10;    val compose_version by extra(&quot;1.5.4&quot;)&#10;    val hilt_version by extra(&quot;2.48&quot;)&#10;    &#10;    repositories {&#10;        google()&#10;        mavenCentral()&#10;        gradlePluginPortal()&#10;    }&#10;    dependencies {&#10;        classpath(&quot;com.android.tools.build:gradle:8.1.0&quot;)&#10;        classpath(&quot;org.jetbrains.kotlin:kotlin-gradle-plugin:1.9.0&quot;)&#10;        classpath(&quot;com.google.dagger:hilt-android-gradle-plugin:${hilt_version}&quot;)&#10;    }&#10;}&#10;&#10;tasks.register(&quot;clean&quot;, Delete::class) {&#10;    delete(rootProject.buildDir)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>